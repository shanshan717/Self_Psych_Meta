if (!require("irrCAC")) install.packages("irrCAC")
if (!require("tidyverse")) install.packages("tidyverse")
library(tidyverse)
library(irrCAC)
# 2. 读取你整理好的表格
# 请确保文件名与你上传的一致
df <- read.csv("../1_Data/AnalysisData/Literature_info/Interrater_Reliability_Raw.csv", stringsAsFactors = FALSE)
getwd()
# 2. 读取你整理好的表格
# 请确保文件名与你上传的一致
df <- read.csv("1_Data/AnalysisData/Literature_info/Interrater_Reliability_Raw.csv", stringsAsFactors = FALSE)
# 3. 自动两两比较并生成 R 列 (0/1)
# 我们假设规律是：第 2 列 vs 第 3 列 -> 生成 R1
# 第 5 列 vs 第 6 列 -> 生成 R2，以此类推
# 获取所有需要配对的起始列索引 (A1, B1, C1...)
pair_starts <- seq(2, ncol(df), by = 3) # 假设每组占3列（C1, C2, R）
# 循环进行计算
for (i in 1:length(pair_starts)) {
col1_idx <- pair_starts[i]
col2_idx <- col1_idx + 1
r_col_idx <- col1_idx + 2
# 逻辑判断：如果两个编码员内容一致且不为空，则为 1，否则为 0
# trimws() 用于去除字符串前后的空格，防止因为多打一个空格导致判定为 0
df[, r_col_idx] <- ifelse(trimws(as.character(df[, col1_idx])) ==
trimws(as.character(df[, col2_idx])), 1, 0)
# 如果其中有一个是空的 (NA)，通常记为 0 或排除，这里设为 0
df[is.na(df[, r_col_idx]), r_col_idx] <- 0
}
df <- read.csv("1_Data/AnalysisData/Literature_info/Interrater_Reliability_Raw.csv", stringsAsFactors = FALSE)
# 3. 自动两两比较并生成 R 列 (0/1)
# 我们假设规律是：第 2 列 vs 第 3 列 -> 生成 R1
# 第 5 列 vs 第 6 列 -> 生成 R2，以此类推
# 获取所有需要配对的起始列索引 (A1, B1, C1...)
pair_starts <- seq(2, ncol(df), by = 3) # 假设每组占3列（C1, C2, R）
# 循环进行计算
for (i in 1:length(pair_starts)) {
col1_idx <- pair_starts[i]
col2_idx <- col1_idx + 1
r_col_idx <- col1_idx + 2
# 逻辑判断：如果两个编码员内容一致且不为空，则为 1，否则为 0
# trimws() 用于去除字符串前后的空格，防止因为多打一个空格导致判定为 0
df[, r_col_idx] <- ifelse(trimws(as.character(df[, col1_idx])) ==
trimws(as.character(df[, col2_idx])), 1, 0)
# 如果其中有一个是空的 (NA)，通常记为 0 或排除，这里设为 0
df[is.na(df[, r_col_idx]), r_col_idx] <- 0
}
# 2. 读取你整理好的表格
# 请确保文件名与你上传的一致
df <- read.csv("1_Data/AnalysisData/Literature_info/Interrater_Reliability_Raw.csv", stringsAsFactors = FALSE)
df <- df[rowSums(is.na(df) | df == "") != ncol(df), ]
# 2. 定义一个更稳健的对比函数
compare_and_score <- function(v1, v2) {
# 统一转为字符，去除前后空格
s1 <- trimws(as.character(v1))
s2 <- trimws(as.character(v2))
# 对比，处理 NA
res <- ifelse(!is.na(s1) & !is.na(s2) & s1 == s2, 1, 0)
return(res)
}
# 3. 自动化寻找所有配对并计算
# 获取所有列名
all_cols <- names(df)
# 逻辑：寻找所有以 '1' 结尾的列，并尝试寻找对应的以 '2' 结尾的列
# 例如：寻找 A1，匹配 A2；寻找 B3，匹配 B4
prefixes_12 <- all_cols[grepl("1$", all_cols)] %>% gsub("1$", "", .)
prefixes_34 <- all_cols[grepl("3$", all_cols)] %>% gsub("3$", "", .)
# 创建一个存储所有 R 结果的新列表，避免修改原列结构导致索引混乱
reliability_list <- list()
# 计算 1 & 2 配对
for (p in prefixes_12) {
c1 <- paste0(p, "1")
c2 <- paste0(p, "2")
if (c1 %in% all_cols & c2 %in% all_cols) {
df[[paste0("R_", p, "12")]] <- compare_and_score(df[[c1]], df[[c2]])
}
}
# 计算 3 & 4 配对
for (p in prefixes_34) {
c3 <- paste0(p, "3")
c4 <- paste0(p, "4")
if (c3 %in% all_cols & c4 %in% all_cols) {
df[[paste0("R_", p, "34")]] <- compare_and_score(df[[c3]], df[[c4]])
}
}
# 4. 提取所有新生成的 R_ 列计算 AC1
r_matrix <- df %>% select(starts_with("R_"))
all_votes <- as.vector(as.matrix(r_matrix))
# 排除 NA 后计算
all_votes <- all_votes[!is.na(all_votes)]
cac_input <- data.frame(Ref = rep(1, length(all_votes)), Actual = all_votes)
# 5. 输出 AC1 结果
final_ac1 <- gwet.ac1.raw(cac_input)
cat("\n--- 最终分析结果 ---\n")
print(final_ac1$est)
# 6. 保存结果
write.csv(df, "1_Data/AnalysisData/Literature_info/Processed_Consistency.csv", row.names = FALSE)
library(tidyverse)
library(irrCAC)
# 读取CSV
df <- read.csv("1_Data/AnalysisData/Literature_info/Interrater_Reliability_Raw.csv", stringsAsFactors = FALSE, check.names = FALSE)
# 找到所有A列
A_cols <- grep("^A[0-9]+$", names(df), value = TRUE)
# 按数字排序（确保 A1 A2 A3 A4 顺序正确）
A_cols <- A_cols[order(as.numeric(sub("A", "", A_cols)))]
# 成对比较
r_index <- 1
for (i in seq(1, length(A_cols), by = 2)) {
col1 <- A_cols[i]
col2 <- A_cols[i + 1]
r_col <- paste0("R", r_index)
df[[r_col]] <- ifelse(
trimws(tolower(df[[col1]])) == trimws(tolower(df[[col2]])),
1, 0
)
r_index <- r_index + 1
}
write.csv(df, "3_Output/7_other/Interrater_Reliability_Raw.csv", row.names = FALSE)
library(tidyverse)
library(irrCAC)
# 读取CSV
df <- read.csv("1_Data/AnalysisData/Literature_info/Interrater_Reliability_Raw.csv", stringsAsFactors = FALSE, check.names = FALSE)
# 找到所有A列
A_cols <- grep("^A[0-9]+$", names(df), value = TRUE)
# 按数字排序（确保 A1 A2 A3 A4 顺序正确）
A_cols <- A_cols[order(as.numeric(sub("A", "", A_cols)))]
# 成对比较
r_index <- 1
for (i in seq(1, length(A_cols), by = 2)) {
col1 <- A_cols[i]
col2 <- A_cols[i + 1]
r_col <- paste0("R", r_index)
df[[r_col]] <- ifelse(
trimws(tolower(df[[col1]])) == trimws(tolower(df[[col2]])),
1, 0
)
r_index <- r_index + 1
}
# 保存结果
write.csv(df, "3_Output/7_other/Interrater_Reliability_Raw.csv", row.names = FALSE)
df <- read.csv("1_Data/AnalysisData/Literature_info/Interrater_Reliability_Raw.csv",
check.names = FALSE, stringsAsFactors = FALSE)
# 3. 提取所有一致性得分列 (R1, R2, R3...)
# 使用 matches("^R\\d+") 精确匹配以 R 开头且后面跟着数字的列
ratings_matrix <- df %>% select(matches("^R\\d+"))
# 检查是否成功提取
print(paste("已提取的一致性判定列数:", ncol(ratings_matrix)))
# 4. 转换数据格式以符合 AC1 计算要求
# AC1 需要对比两个评分者的判定。
# 在你的数据中，R列本身就是判定的结果（1=一致，0=不一致）。
# 我们构造一个“理想标准”（全为1）与“实际得分”进行对比。
actual_scores <- as.vector(as.matrix(ratings_matrix))
actual_scores <- actual_scores[!is.na(actual_scores)] # 剔除空值
# 构造对比矩阵：第一列是理想的 1（完全一致），第二列是你的实际 0/1
cac_input <- data.frame(
Standard = rep(1, length(actual_scores)),
Actual = actual_scores
)
# 5. 计算 AC1
# 使用 irrCAC 包中的 gwet.ac1.raw 函数
ac1_result <- gwet.ac1.raw(cac_input)
# 6. 打印结果
cat("\n========================================\n")
cat("评分者一致性分析 (AC1) 结果:\n")
cat("AC1 系数值 (Coefficient):", round(ac1_result$est$coeff.val, 4), "\n")
cat("95% 置信区间 (95% CI): [", round(ac1_result$est$conf.int[1], 4), ",",
round(ac1_result$est$conf.int[2], 4), "]\n")
df <- read.csv("1_Data/AnalysisData/Literature_info/Interrater_Reliability_Raw.csv",
check.names = FALSE, stringsAsFactors = FALSE)
# 3. 提取所有一致性得分列 (R1, R2, R3...)
# 使用 matches("^R\\d+") 精确匹配以 R 开头且后面跟着数字的列
ratings_matrix <- df %>% select(matches("^R\\d+"))
# 检查是否成功提取
print(paste("已提取的一致性判定列数:", ncol(ratings_matrix)))
# 4. 转换数据格式以符合 AC1 计算要求
# AC1 需要对比两个评分者的判定。
# 在你的数据中，R列本身就是判定的结果（1=一致，0=不一致）。
# 我们构造一个“理想标准”（全为1）与“实际得分”进行对比。
actual_scores <- as.vector(as.matrix(ratings_matrix))
actual_scores <- actual_scores[!is.na(actual_scores)] # 剔除空值
# 构造对比矩阵：第一列是理想的 1（完全一致），第二列是你的实际 0/1
cac_input <- data.frame(
Standard = rep(1, length(actual_scores)),
Actual = actual_scores
)
# 5. 计算 AC1
# 使用 irrCAC 包中的 gwet.ac1.raw 函数
ac1_result <- gwet.ac1.raw(cac_input)
# 6. 打印结果
cat("\n========================================\n")
cat("评分者一致性分析 (AC1) 结果:\n")
# 提取系数
coeff <- as.numeric(ac1_result$est$coeff.val)
cat("AC1 系数值 (Coefficient):", round(coeff, 4), "\n")
# 提取置信区间（针对 irrCAC 结果表的安全提取方式）
# 有时结果存在于 $est$conf.int，有时在 $est$lcb 和 $est$ucb
lcb <- as.numeric(ac1_result$est$conf.int[1])
ucb <- as.numeric(ac1_result$est$conf.int[2])
# 如果上面的提取还是报错，请尝试这种直接从结果框提取的方式：
# lcb <- ac1_result$est$lcb
# ucb <- ac1_result$est$ucb
cat("95% 置信区间 (95% CI): [", round(lcb, 4), ",", round(ucb, 4), "]\n")
cat("总体一致率 (Percent Agreement):", round(as.numeric(ac1_result$est$pa), 4) * 100, "%\n")
cat("========================================\n")
# Environment setup
base::rm(list = base::ls())
base::library(tidyverse)
base::library(irrCAC)
# Define file paths
input_path  <- "1_Data/AnalysisData/Literature_info/Interrater_Reliability_Raw.csv"
output_path <- "3_Output/7_other/Interrater_Reliability_Processed.csv"
